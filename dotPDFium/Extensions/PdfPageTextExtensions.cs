using nebulae.dotPDFium;
using nebulae.dotPDFium.Native;

namespace nebulae.dotPdfium.Extensions;

/// <summary>
/// Provides extension methods for working with text content in PDF pages.
/// </summary>
/// <remarks>This class includes methods for performing hit tests, extracting text, and retrieving character
/// indices within specified regions of a PDF page. These methods are designed to facilitate text manipulation and
/// analysis in PDF documents.</remarks>
public static class PdfPageTextExtensions
{
    /// <summary>
    /// Determines the index of the character at the specified position within the text of a PDF page.
    /// </summary>
    /// <remarks>This method performs a hit test to identify the character at the given position on the PDF
    /// page.  The position is matched to a character based on the specified tolerance, which defines the allowable 
    /// distance from the position to the character's bounding box.</remarks>
    /// <param name="text">The <see cref="PdfPageText"/> object representing the text content of the PDF page.</param>
    /// <param name="x">The x-coordinate of the position to test, in the coordinate space of the PDF page.</param>
    /// <param name="y">The y-coordinate of the position to test, in the coordinate space of the PDF page.</param>
    /// <param name="tol">The tolerance, in points, for matching the position to a character. Defaults to 2.0.</param>
    /// <returns>The zero-based index of the character at the specified position, or -1 if no character is found within the
    /// specified tolerance.</returns>
    public static int HitTestChar(this PdfPageText text, double x, double y, double tol = 2.0)
            => text.GetCharIndexAtPos(x, y, tol, tol);

    /// <summary>
    /// Retrieves the indices of characters within a specified rectangular region on a PDF page.
    /// </summary>
    /// <remarks>This method performs a simple axis-aligned bounding box (AABB) intersection check for each
    /// character in the text. Characters that fall outside the specified rectangle are excluded.</remarks>
    /// <param name="text">The <see cref="PdfPageText"/> object representing the text content of the PDF page.</param>
    /// <param name="rect">The <see cref="FsRectF"/> defining the rectangular region in PDF coordinate space. The region is specified by
    /// its left, right, bottom, and top boundaries.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of integers representing the indices of characters that intersect with the
    /// specified rectangular region.</returns>
    public static IEnumerable<int> CharsInRect(this PdfPageText text, FsRectF rect)
    {
        // Simple AABB intersection over all chars; callers can refine if needed.
        int n = text.CountChars;
        for (int i = 0; i < n; i++)
        {
            if (!text.TryGetCharBox(i, out double l, out double r, out double b, out double t))
                continue;

            // rect: left<=x<=right, bottom<=y<=top (PDF coordinate space)
            if (r < rect.left || l > rect.right || t < rect.bottom || b > rect.top)
                continue;

            yield return i;
        }
    }

    /// <summary>
    /// Extracts text from a specified rectangular region within a PDF page.
    /// </summary>
    /// <remarks>The extracted text is sorted by line (descending vertical position in PDF coordinates) and
    /// then by horizontal position. This method gracefully handles cases where fonts or glyphs are broken, ensuring
    /// reliable text extraction.</remarks>
    /// <param name="text">The <see cref="PdfPageText"/> object representing the text content of the PDF page.</param>
    /// <param name="rect">The rectangular region, defined in PDF coordinates, from which to extract text.</param>
    /// <param name="dropGenerated">A value indicating whether to exclude text generated by the PDF rendering engine, such as synthetic glyphs. <see
    /// langword="true"/> to exclude generated text; otherwise, <see langword="false"/>.</param>
    /// <param name="markUnmapped">A value indicating whether to replace characters with Unicode mapping errors. <see langword="true"/> to replace
    /// unmapped characters with the Unicode replacement character (U+FFFD); otherwise, <see langword="false"/>.</param>
    /// <returns>A <see cref="string"/> containing the extracted text from the specified region. Returns an empty string if no
    /// text is found within the region.</returns>
    public static string ExtractTextInRect(
        this PdfPageText text,
        FsRectF rect,
        bool dropGenerated = true,
        bool markUnmapped = false)
    {
        // Gather char indices we intersect
        var ids = text.CharsInRect(rect).ToList();
        if (ids.Count == 0) return string.Empty;

        // Sort by line (Y desc in PDF space) then X asc
        ids.Sort((a, b) =>
        {
            text.TryGetCharBox(a, out var la, out var ra, out var ba, out var ta);
            text.TryGetCharBox(b, out var lb, out var rb, out var bb, out var tb);
            // compare vertical centers (PDF y grows up; larger 'top' is higher)
            double ya = (ta + ba) * 0.5;
            double yb = (tb + bb) * 0.5;
            int cmpY = -ya.CompareTo(yb); // descending
            if (cmpY != 0) return cmpY;

            // then by left x
            return la.CompareTo(lb);
        });

        var sb = new System.Text.StringBuilder(ids.Count);

        for (int i = 0; i < ids.Count; i++)
        {
            int idx = ids[i];

            // Degrade gracefully on broken fonts/ligatures
            if (dropGenerated && text.IsGenerated(idx)) continue;

            if (markUnmapped && text.HasUnicodeMapError(idx))
            {
                sb.Append('\uFFFD'); // replacement char
                continue;
            }

            // Pull one char at a time
            // GetTextRange is safe; PDFium may return 0/1 length if weird glyphs
            var ch = text.GetTextRange(idx, 1);
            if (!string.IsNullOrEmpty(ch))
                sb.Append(ch);
        }

        return sb.ToString();
    }
}
