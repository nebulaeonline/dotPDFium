<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Getting Started with dotPDFium: | dotPDFium </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Getting Started with dotPDFium: | dotPDFium ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="dotPDFium">
            dotPDFium
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="getting-started-with-dotpdfium">Getting Started with dotPDFium:</h1>

<p>The first thing to do is initialize the library before use (otherwise you'll get nasty library not found exceptions):</p>
<pre><code class="lang-csharp">PDFiumEngine.Init();
</code></pre>
<p>This handles initialization of both dotPDFium and the underlying pdfium library.</p>
<p>The last thing to remember to do is to shudown when you've finished with the library:</p>
<pre><code class="lang-csharp">PDFiumEngine.Shutdown();
</code></pre>
<hr>
<h2 id="dotpdfium-basics">dotPDFium Basics</h2>
<p>The library is designed to abstract away the pain of calling PDFium's native functions. It is a powerful library written in C++, but its external interface is (mostly) C-based. So to spare you that torture, we have wrapped up the bulk of its functionality into easy-to-use and idiomatic C# code.</p>
<p>The first thing you will want to do is create a <a href="https://nebulae.online/dotPDFium/api/nebulae.dotPDFium.PdfDocument.html">PdfDocument</a> object. You can do that by</p>
<ul>
<li>creating a completely new document:</li>
</ul>
<pre><code class="lang-csharp">var doc = PdfDocument.CreateNew();
</code></pre>
<ul>
<li>loading an existing document from the file system:</li>
</ul>
<pre><code class="lang-csharp">var doc = PdfDocument.LoadFromFile(&quot;/path/to/file.pdf&quot;);
</code></pre>
<p>or</p>
<pre><code class="lang-csharp">PdfDocument doc;
var result = PdfDocument.TryLoadFromFile(&quot;/path/to/file.pdf&quot;, doc)
</code></pre>
<ul>
<li>loading a document from memory:</li>
</ul>
<pre><code class="lang-csharp">var doc = PdfDocument.LoadFromMemory(byteBuffer);
</code></pre>
<hr>
<p>Once you have your document object, you can work with the pages of the document via the <a href="https://nebulae.online/dotPDFium/api/nebulae.dotPDFium.PdfPage.html">PdfPage</a> class.</p>
<ul>
<li>creating a new page:</li>
</ul>
<pre><code class="lang-csharp">var page = doc.CreatePage(0, 612, 792);
</code></pre>
<p>page units are in points, which are 1/72 of an inch (thanks Adobe); this is a standard U.S. 8.5&quot; x 11&quot; page.</p>
<ul>
<li>opening an existing page:</li>
</ul>
<pre><code class="lang-csharp">using var page = doc.LoadPage(0);
</code></pre>
<p>pages are loaded by 0-based index, but be warned that page indexes can and will change out from under you if you insert or delete pages.</p>
<hr>
<ul>
<li>retrieving document text can be straightforward (please see the caveats below):</li>
</ul>
<pre><code class="lang-csharp">using var doc = PdfDocument.LoadFromFile(&quot;example.pdf&quot;);
var page = doc.LoadPage(0);
var textPage = page.GetOrLoadText();

string fullText = textPage.GetTextRange(0, textPage.CountChars);
Console.WriteLine(fullText);
</code></pre>
<ul>
<li>There are functions that handle extracting the text from a pdf, including locating characters at certain places on the page:</li>
</ul>
<pre><code class="lang-csharp">using var doc = PdfDocument.LoadFromFile(&quot;example.pdf&quot;);
var page = doc.LoadPage(0);

// Load the text layer
var text = page.GetOrLoadText();

// Choose a point on the page in page coordinates (e.g., 72 = 1 inch from bottom-left)
double x = 150.0;
double y = 500.0;

// Find character at that point
int index = text.GetCharIndexAtPos(x, y);

if (index &gt;= 0 &amp;&amp; index &lt; text.CountChars)
{
    uint ch = text.GetChar(index);
    Console.WriteLine($&quot;Character at ({x}, {y}) is: {(char)ch} (U+{ch:X4})&quot;);
}
else
{
    Console.WriteLine(&quot;No character found at that point.&quot;);
}
</code></pre>
<hr>
<p>page rendering is done through the <a href="https://nebulae.online/dotPDFium/api/nebulae.dotPDFium.PdfBitmap.html">PdfBitmap</a> class and can be handled via System.Drawing on Windows, or you can use SixLabors' ImageSharp for true cross-platform compatibility. Another key point is that PdfDocuments are measured in points, while PdfBitmaps are measured in pixels. There are functions to convert between the two coordinate systems- see <a href="https://nebulae.online/dotPDFium/api/nebulae.dotPDFium.PdfPage.html#nebulae_dotPDFium_PdfPage_DeviceToPage_System_Int32_System_Int32_System_Int32_System_Int32_nebulae_dotPDFium_Native_PdfPageRotation_System_Int32_System_Int32_System_Double__System_Double__">DeviceToPage</a> and <a href="https://nebulae.online/dotPDFium/api/nebulae.dotPDFium.PdfPage.html#nebulae_dotPDFium_PdfPage_PageToDevice_System_Int32_System_Int32_System_Int32_System_Int32_nebulae_dotPDFium_Native_PdfPageRotation_System_Double_System_Double_System_Int32__System_Int32__">PageToDevice</a></p>
<ul>
<li>Here's the System.Drawing example:</li>
</ul>
<pre><code class="lang-csharp">using var doc = PdfDocument.LoadFromFile(&quot;example.pdf&quot;);
var page = doc.LoadPage(0);

int width = 800;
int height = (int)(width * (page.Height / page.Width));

using var pdfBmp = PdfBitmap.Create(width, height, PdfBitmapFormat.BGRA);
page.RenderToBitmap(pdfBmp, 0, 0, width, height);

using var bmp = new System.Drawing.Bitmap(width, height, width * 4, System.Drawing.Imaging.PixelFormat.Format32bppArgb, pdfBmp.Scan0);
bmp.Save(&quot;output-drawing.png&quot;, System.Drawing.Imaging.ImageFormat.Png);
</code></pre>
<ul>
<li>and the ImageSharp example:</li>
</ul>
<pre><code class="lang-csharp">using var doc = PdfDocument.LoadFromFile(&quot;example.pdf&quot;);
var page = doc.LoadPage(0);

int width = 800;
int height = (int)(width * (page.Height / page.Width));

using var pdfBmp = PdfBitmap.Create(width, height, PdfBitmapFormat.BGRA);
page.RenderToBitmap(pdfBmp, 0, 0, width, height);

// Wrap PDFium memory with ImageSharp without copying
unsafe
{
    var image = Image.WrapMemory&lt;SixLabors.ImageSharp.PixelFormats.Rgba32&gt;(
        new Span&lt;SixLabors.ImageSharp.PixelFormats.Rgba32&gt;((void*)pdfBmp.Scan0, width * height),
        width,
        height
    );

    image.Save(&quot;output-sixlabors.png&quot;);
}

</code></pre>
<hr>
<ul>
<li>dotPDFium does its best to hide any and all pointers into PDFium from the user. But if you ever need a pointer to call a native function (all are publicly exposed so you can venture out as you see fit), the object pointers are all accessed like so:</li>
</ul>
<pre><code class="lang-csharp">myPdfObject.Handle
</code></pre>
<p>Handles can be passed to native functions without issue, but you are on your own if you venture over to that side of the library. Calls made outside the dotPDFium supplied interfaces are your responsibility to manage ownership and object destruction.</p>
<hr>
<p>It's important to note that PDFium is a canvas-based renderer and not a text-flow based one. What that means is that each object has its own transformation matrix (rotation &amp; scaling) plus stroke, color, fill, font and weight. What this means is that sometimes dealing with it can be finicky for text extraction, because each <em>character</em> might be (and is) its own object. There is no support for line endings or word wrapping. We are going to add some of these functions for convenience, but you have to keep in mind the limitations of the canvas rendering perspective of the underlying PDFium.</p>
<hr>
<p>Those are the very basics to get you started. Check out the PdfDocument and PdfPage API docs, because most functions are fairly straightforward.</p>
<p>Check out the project tests on the Github site for some more complex examples like rendering to a bitmap and then painting to that bitmap and saving to a png file.</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
